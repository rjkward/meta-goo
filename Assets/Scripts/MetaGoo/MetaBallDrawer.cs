using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Serialization;

namespace MetaGoo
{
    public class MetaBallDrawer : MonoBehaviour
    {
        private const int Samples = 40;

        private const int MaxVertsPerVoxel = 3 * 5;

        private const int MaxXSamples = 40;
        private const int MaxYSamples = 40;
        private const int MaxZSamples = 40;

        private const int MaxVoxels = MaxXSamples * MaxYSamples * MaxZSamples;
        private const int MaxVerts = MaxVoxels * MaxVertsPerVoxel;

        [SerializeField]
        private Material _drawBufferMaterial;

        [SerializeField]
        private ComputeShader _metaBallsCompute;

        [SerializeField]
        private ComputeShader _marchingCubes;

        [SerializeField]
        private ComputeShader _normals;

        [SerializeField]
        private ComputeShader _clearBuffer;

        private ComputeBuffer _fieldBuffer;
        
        private ComputeBuffer _meshBuffer;

        private RenderTexture _normalsBuffer;

        private ComputeBuffer _cubeEdgeFlags;

        private ComputeBuffer _triangleConnectionTable;

        private BallData[] _ballDataArray;

        private struct BallData
        {
            public Vector3 Position;
            public float SqrRadius;
        }

        private ComputeBuffer _ballsBuffer;

        [SerializeField]
        private float _threshold = 1f;

        private const int MaxBalls = 32;

        void Start()
        {
            // data for meta-ball field function
            _ballsBuffer = new ComputeBuffer(MaxBalls, sizeof(float) * 4);
            _ballDataArray = new BallData[MaxBalls];
            
            // field strength voxel values for marching cubes algo
            _fieldBuffer = new ComputeBuffer(MaxVoxels, sizeof(float));

            // implied voxel normals, sampled to generate mesh normals
            _normalsBuffer = new RenderTexture(MaxXSamples, MaxYSamples, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
            _normalsBuffer.volumeDepth = MaxZSamples;
            _normalsBuffer.dimension = TextureDimension.Tex3D;
            _normalsBuffer.enableRandomWrite = true;
            _normalsBuffer.useMipMap = false;
            _normalsBuffer.Create();

            // lookup tables for marching cubes algo
            _cubeEdgeFlags = new ComputeBuffer(256, sizeof(int));
            _cubeEdgeFlags.SetData(LookupTables.CubeEdgeFlags);
            _triangleConnectionTable = new ComputeBuffer(256 * 16, sizeof(int));
            _triangleConnectionTable.SetData(LookupTables.TriangleConnectionTable);

            // verts generated by the marching cubes (final metaball mesh)
            _meshBuffer = new ComputeBuffer(MaxVerts, sizeof(float) * 7);
            
            SetStaticComputeShaderBuffers();
        }

        private void SetStaticComputeShaderBuffers()
        {
            _clearBuffer.SetBuffer(0, "_Buffer", _meshBuffer);
            
            _metaBallsCompute.SetBuffer(0, "_Balls", _ballsBuffer);
            _metaBallsCompute.SetBuffer(0, "_Result", _fieldBuffer);
            
            _normals.SetBuffer(0, "_Field", _fieldBuffer);
            _normals.SetTexture(0, "_Result", _normalsBuffer);
            
            _marchingCubes.SetBuffer(0, "_Voxels", _fieldBuffer);
            _marchingCubes.SetTexture(0, "_Normals", _normalsBuffer);
            _marchingCubes.SetBuffer(0, "_Buffer", _meshBuffer);
            _marchingCubes.SetBuffer(0, "_CubeEdgeFlags", _cubeEdgeFlags);
            _marchingCubes.SetBuffer(0, "_TriangleConnectionTable", _triangleConnectionTable);
        }
        
        public void DrawMetaBalls(List<SphereCollider> balls, Bounds bounds)
        {
            int width = Samples;
            int height = Samples;
            int depth = Samples;

            var scale = new Vector3(
                bounds.size.x / (float)width,
                bounds.size.y / (float)height,
                bounds.size.z / (float)depth);
            
            //Clear the buffer from last frame.
            _clearBuffer.SetInt("_Width", width);
            _clearBuffer.SetInt("_Height", height);
            _clearBuffer.SetInt("_Depth", depth);

            _clearBuffer.Dispatch(0, width / 8, height / 8, depth / 8);

            // generate voxel field data
            _metaBallsCompute.SetInt("_Width", width);
            _metaBallsCompute.SetInt("_Height", height);
            _metaBallsCompute.SetVector("_Offset", bounds.min);
            _metaBallsCompute.SetVector("_Scale", scale);
            SetBallData(balls);
            _ballsBuffer.SetData(_ballDataArray);
            _metaBallsCompute.SetInt("_BallCount", Math.Min(MaxBalls, balls.Count));
            
            _metaBallsCompute.Dispatch(0, width / 8, height / 8, depth / 8);

            
            // generate voxel normals
            // TODO generate metaball vert normals properly instead of sampling implied voxel normals
            _normals.SetInt("_Width", width);
            _normals.SetInt("_Height", height);

            _normals.Dispatch(0, width / 8, height / 8, depth / 8);

            // generate the mesh
            _marchingCubes.SetInt("_Width", width);
            _marchingCubes.SetInt("_Height", height);
            _marchingCubes.SetInt("_Depth", depth);
            _marchingCubes.SetInt("_Border", 0);
            _marchingCubes.SetFloat("_Target", _threshold);
            _marchingCubes.SetVector("_Offset", bounds.min);
            _marchingCubes.SetVector("_Scale", scale);

            _marchingCubes.Dispatch(0, width / 8, height / 8, depth / 8);
            
            // Draw metaballs
            // TODO make this a field so we don't allocate more than one
            MaterialPropertyBlock properties = new MaterialPropertyBlock();
            properties.SetBuffer("_Buffer", _meshBuffer);
            
            Graphics.DrawProcedural(
                material: _drawBufferMaterial,
                bounds: bounds,
                topology: MeshTopology.Triangles,
                vertexCount: width * height * depth * MaxVertsPerVoxel,
                instanceCount: 1,
                camera: null,
                properties: properties,
                castShadows: ShadowCastingMode.On,
                receiveShadows: true);
        }

        private void SetBallData(List<SphereCollider> balls)
        {
            int count = Math.Min(MaxBalls, balls.Count);
            for (int i = 0; i < count; i++)
            {
                SphereCollider ball = balls[i];
                _ballDataArray[i] = SphereColliderToBallData(ball);
            }
            
            BallData SphereColliderToBallData(SphereCollider ball)
            {
                Transform transform = ball.transform;
                Vector3 p = transform.TransformPoint(ball.center);
                
                // assume scale is uniform for all 3 axes
                float radius = transform.lossyScale.x * ball.radius;
                return new BallData { Position = p, SqrRadius = radius * radius};
            }
        }

        void OnDestroy()
        {
            _fieldBuffer.Release();
            _meshBuffer.Release();
            _cubeEdgeFlags.Release();
            _triangleConnectionTable.Release();
            _normalsBuffer.Release();
            _ballsBuffer.Release();
        }

    }
}